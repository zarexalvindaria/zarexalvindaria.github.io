<section class="projects">
  <div class="content-wrap divider">
    <h2 class="projects">Featured Projects</h2>

    <!-- Project 1 -->
    <section class="project-item">
      <!-- Start Carousel of Images -->
      <ngb-carousel *ngIf="techtrendsImages">
        <ng-template ngbSlide>
          <div class="carousel-img-wrapper">
            <img [src]="techtrendsImages[0]" alt="GitHub Actions" />
          </div>
          <div class="carousel-caption">
            <h3>GitHub Actions</h3>
            <p>
              Used Continuous Integration (CI) via GitHub Actions to build, tag,
              and push the TechTrends Docker image to DockerHub.
            </p>
          </div>
        </ng-template>
        <ng-template ngbSlide>
          <div class="carousel-img-wrapper">
            <img [src]="techtrendsImages[1]" alt="ArgoCD" />
          </div>
          <div class="carousel-caption">
            <h3 class="argo-cd">Continuous Delivery with ArgoCD</h3>
            <p class="argo-cd">
              Used ArgoCD for Continuous Delivery--to release the TechTrends app
              to staging and production environments using templated manifests
              from the Helm chart.
            </p>
          </div>
        </ng-template>
      </ngb-carousel>
      <!-- End Carousel -->

      <h3>TechTrends</h3>
      <button
        type="button"
        class="btn btn-dark"
        data-toggle="tooltip"
        data-placement="top"
        title="Kubernetes"
        *ngFor="let tag of techtrendsTags"
      >
        {{ tag }}
      </button>

      <p>
        TechTrends is an online news-sharing platform that enables access to the
        latest news within the cloud-native ecosystem. It is written using the
        Flask framework and uses SQLite to store submitted articles.
      </p>
      <p>
        In this project, I built endpoints for the TechTrends web application
        displaying the health of the application, metrics such as the total
        number of posts in the database, and connection requests to the
        application. I also extended the application to log events such as when
        an article is created or retrieved, when a non-existing article is
        accessed and when certain pages are accessed.
      </p>
      <p>
        I have also packaged the application using Docker—allowing the app to
        run locally inside a Docker container and used Continuous Integration
        (CI) via GitHub Actions to build, tag, and push the TechTrends Docker
        image to DockerHub.
      </p>
      <p>
        I have also deployed the web application in a Kubernetes cluster using
        k3s—creating declarative Kubernetes manifests and releasing the
        application to the sandbox environment. Throughout the deployment, I
        used Helm, a template configuration manager, to parameterize the web
        app's manifests.
      </p>
      <p>
        As the final step, I released the TechTrends application automatically
        using Continuous Delivery with ArgoCD to staging and production
        environments using templated manifests from the Helm chart.
      </p>
    </section>

    <!-- Project 2 -->
    <section class="project-item">
      <img [src]="udaconnectImages[0]" alt="Udaconnect" />
      <h3>Udaconnect (Message Passing & Refactoring)</h3>
      <p>
        Udaconnect is an application running in Flask that uses location data
        from mobile devices to help conference attendees connect by being
        informed when they have attended the same booths and presentations at an
        event.
      </p>
      <p>
        In this project, I have refactored Udaconnect's monolithic architecture
        into a microservice architecture using several message passing
        techniques. First, I have reviewed the application and chose the best
        message passing techniques suitable for each microservice—documenting
        the plan in an architecture diagram and showing the services and message
        passing techniques between them. Along the way, I used Kubernetes while
        maintaining the core functionality of the project.
      </p>
      <p>
        I refactored the application and implemented Kafka, gRPC, and RESTful
        API to allow message passing between the microservices.
      </p>
      <p>
        Lastly, I created OpenAPI documentation for the API endpoints and
        provided a Postman library for the endpoints I created.
      </p>
    </section>

    <!-- Project 3 -->
    <section class="project-item">
      <img [src]="observabilityImages[0]" alt="Observability" />
      <h3>Observability & Metrics Dashboard</h3>
      <p>
        In this project, I created dashboards that use multiple graphs to
        monitor a sample application deployed on a Kubernetes cluster. I used
        Prometheus, Jaeger, and Grafana to monitor, trace and visualize the
        needed metrics.
      </p>
      <p>
        First, I installed Helm, Jaeger, Grafana, and Prometheus in a Kubernetes
        cluster—ensuring that all pods and services are running for all the
        components. Then, I wrote service level indicator (SLI) metrics and
        built a dashboard to measure the KPIs.
      </p>
      <p>
        I added Jaeger spans to measure the processes on the backend of the
        Flask application and then integrated Jaeger's collected metric to the
        Grafana dashboard.
      </p>
      <p>
        Lastly, I created a dashboard containing graphs that capture all the
        metrics of the KPIs that adequately represented the SLIs and SLOs.
      </p>
    </section>

    <!-- Project 4 -->
    <section class="project-item">
      <img [src]="msecurityImages[0]" alt="Hardened Microservice" />
      <h3>Hardened Microservice</h3>
      <p>
        In this project, I have applied what I learned about STRIDE to threat
        model a microservices environment. Then, I defined its security
        architecture and its attack surfaces.
      </p>
      <p>
        Next, I hardened the application's Docker environment using
        Docker-bench. I also created an RKE cluster and walked through a testing
        methodology to harden a Kubernetes cluster.
      </p>
      <p>
        I then hardened and deployed a Flask application after identifying and
        remediating its vulnerable libraries and code using Grype and Trivy.
      </p>
      <p>
        Afterward, I implemented runtime monitoring using Grafana to visualize
        runtime security alerts via Sysdig Falco.
      </p>
      <p>
        I ran an unknown payload containing malicious commands into the
        Kubernetes cluster to simulate a security incident. Then, I remediated
        the incident, documented, and prepared an incident response report to be
        submitted to a Chief Technology Officer—describing the incident, its
        impact, and the remediation steps taken.
      </p>
    </section>
  </div>
</section>
